diff --git a/chrome/browser/ui/layout_constants.cc b/chrome/browser/ui/layout_constants.cc
index 4e5901f95885b..8617e0e7afe91 100644
--- a/chrome/browser/ui/layout_constants.cc
+++ b/chrome/browser/ui/layout_constants.cc
@@ -29,7 +29,7 @@ int GetLayoutConstant(LayoutConstant constant) {
     case BOOKMARK_BAR_HEIGHT: {
       // The fixed margin ensures the bookmark buttons appear centered relative
       // to the white space above and below.
-      const int bookmark_bar_attached_vertical_margin = 6;
+      const int bookmark_bar_attached_vertical_margin = 10;
       return GetLayoutConstant(BOOKMARK_BAR_BUTTON_HEIGHT) +
              bookmark_bar_attached_vertical_margin;
     }
@@ -93,12 +93,12 @@ int GetLayoutConstant(LayoutConstant constant) {
     case TAB_CLOSE_BUTTON_SIZE:
       return touch_ui ? 24 : 16;
     case TAB_HEIGHT:
-      return 34 + GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+      return 36 + GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
     case TAB_STRIP_HEIGHT:
       return GetLayoutConstant(TAB_HEIGHT) +
              GetLayoutConstant(TAB_STRIP_PADDING);
     case TAB_STRIP_PADDING:
-      return 6;
+      return 4;
     case TAB_SEPARATOR_HEIGHT:
       return touch_ui ? 24 : 20;
     case TAB_PRE_TITLE_PADDING:
diff --git a/chrome/browser/ui/tabs/tab_style.cc b/chrome/browser/ui/tabs/tab_style.cc
index eb6789e6212b6..a3894efb96e6a 100644
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -27,8 +27,8 @@ constexpr int kChromeRefreshSeparatorHeight = 16;
 constexpr int kChromeRefreshTabVerticalPadding = 6;
 constexpr int kChromeRefreshTabHorizontalPadding = 8;
 
-// The standard tab width is 232 DIP, excluding separators and overlap.
-constexpr int kTabWidth = 232;
+// The standard tab width is 200 DIP, excluding separators and overlap.
+constexpr int kTabWidth = 200;
 
 }  // namespace
 
diff --git a/chrome/browser/ui/toolbar/app_menu_model.cc b/chrome/browser/ui/toolbar/app_menu_model.cc
index 2934bdcab48bb..9aa1eaf769176 100644
--- a/chrome/browser/ui/toolbar/app_menu_model.cc
+++ b/chrome/browser/ui/toolbar/app_menu_model.cc
@@ -2241,7 +2241,7 @@ bool AppMenuModel::AddDefaultBrowserMenuItems() {
         IDC_SET_BROWSER_AS_DEFAULT,
         l10n_util::GetStringUTF16(IDS_SET_BROWSER_AS_DEFAULT_MENU_ITEM),
         ui::ImageModel::FromVectorIcon(omnibox::kProductChromeRefreshIcon,
-                                       ui::kColorMenuIcon, kDefaultIconSize));
+                                       ui::kColorMenuIconOnEmphasizedBackground, kDefaultIconSize));
     SetElementIdentifierAt(GetItemCount() - 1,
                            AppMenuModel::kSetBrowserAsDefaultMenuItem);
     return true;
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
index a00e5c202067f..ba59857e8378a 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
@@ -708,26 +708,7 @@ void BookmarkBarView::Layout(PassKey) {
 
   const int button_height = GetLayoutConstant(BOOKMARK_BAR_BUTTON_HEIGHT);
 
-  // Bookmark bar buttons should be centered between the bottom of the location
-  // bar and the bottom of the bookmarks bar, which requires factoring in the
-  // bottom margin of the toolbar into the button position.
-  int toolbar_bottom_margin = 0;
-  // Note: |browser_view_| may be null during tests.
-  if (browser_view_ && !browser_view_->IsFullscreen()) {
-    toolbar_bottom_margin =
-        browser_view_->toolbar()->height() -
-        browser_view_->GetLocationBarView()->bounds().bottom();
-  }
-  // Center the buttons in the total available space.
-  const int total_height = GetContentsBounds().height() + toolbar_bottom_margin;
-  const auto center_y = [total_height, toolbar_bottom_margin](int height) {
-    const int top_margin = (total_height - height) / 2;
-    // Calculate the top inset in the bookmarks bar itself (not counting the
-    // space in the toolbar) but do not allow the buttons to leave the bookmarks
-    // bar.
-    return std::max(0, top_margin - toolbar_bottom_margin);
-  };
-  const int y = center_y(button_height);
+  const int y = 5;
 
   gfx::Size all_bookmarks_pref = all_bookmarks_button_->GetVisible()
                                      ? all_bookmarks_button_->GetPreferredSize()
@@ -835,7 +816,7 @@ void BookmarkBarView::Layout(PassKey) {
       gfx::Size saved_tab_groups_separator_view_pref =
           saved_tab_groups_separator_view_->GetPreferredSize();
       saved_tab_groups_separator_view_->SetBounds(
-          x, center_y(saved_tab_groups_separator_view_pref.height()),
+          x, 5 + (button_height - saved_tab_groups_separator_view_pref.height()) / 2,
           saved_tab_groups_separator_view_pref.width(),
           saved_tab_groups_separator_view_pref.height());
 
@@ -905,7 +886,7 @@ void BookmarkBarView::Layout(PassKey) {
   // Bookmarks Separator.
   if (bookmarks_separator_view_->GetVisible()) {
     bookmarks_separator_view_->SetBounds(
-        x, center_y(bookmarks_separator_pref.height()),
+        x, 5 + (button_height - bookmarks_separator_pref.height()) / 2,
         bookmarks_separator_pref.width(), bookmarks_separator_pref.height());
 
     x += bookmarks_separator_pref.width();
@@ -1107,6 +1088,11 @@ views::View::DropCallback BookmarkBarView::GetDropCallback(
 
 void BookmarkBarView::OnThemeChanged() {
   views::AccessiblePaneView::OnThemeChanged();
+  if (GetColorProvider()) {
+    SetBorder(views::CreateSolidSidedBorder(
+        gfx::Insets::TLBR(1, 0, 0, 0),
+        GetColorProvider()->GetColor(kColorToolbarSeparator)));
+  }
   UpdateAppearanceForTheme();
 }
 
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index da82293cba539..2dbe7d318cd7b 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -20,7 +20,6 @@
 #include "build/build_config.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/app/vector_icons/vector_icons.h"
-#include "chrome/browser/autocomplete/aim_eligibility_service_factory.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/command_updater.h"
 #include "chrome/browser/content_settings/host_content_settings_map_factory.h"
@@ -41,6 +40,7 @@
 #include "chrome/browser/ui/autofill/payments/save_card_bubble_controller_impl.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_actions.h"
+#include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_element_identifiers.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_window.h"
@@ -465,21 +465,7 @@ void LocationBarView::Init() {
   // |browser_| may be null when LocationBarView is used for non-Browser windows
   // such as PresentationReceiverWindowView, which do not support page actions.
   if (browser_) {
-    // Page action icons that participate in label animations should be added
-    // first so that they appear on the left side of the icon container.
-    // TODO(crbug.com/40835681): Improve the ordering heuristics for page action
-    // icons and determine a way to handle simultaneous icon animations.
-    if (base::FeatureList::IsEnabled(commerce::kProductSpecifications)) {
-      params.types_enabled.push_back(
-          PageActionIconType::kProductSpecifications);
-    }
-    params.types_enabled.push_back(PageActionIconType::kDiscounts);
-    params.types_enabled.push_back(PageActionIconType::kPriceInsights);
-    params.types_enabled.push_back(PageActionIconType::kPriceTracking);
-
-    if (optimization_guide::features::ShouldEnableOptimizationGuideIconView()) {
-      params.types_enabled.push_back(PageActionIconType::kOptimizationGuide);
-    }
+    // Keep only essential page action icons, removing Google-specific features
     params.types_enabled.push_back(PageActionIconType::kClickToCall);
     params.types_enabled.push_back(PageActionIconType::kAutofillAddress);
     params.types_enabled.push_back(PageActionIconType::kManagePasswords);
@@ -491,7 +477,6 @@ void LocationBarView::Init() {
     params.types_enabled.push_back(PageActionIconType::kTranslate);
     params.types_enabled.push_back(PageActionIconType::kZoom);
     params.types_enabled.push_back(PageActionIconType::kFileSystemAccess);
-
     params.types_enabled.push_back(PageActionIconType::kCookieControls);
     params.types_enabled.push_back(
         PageActionIconType::kPaymentsOfferNotification);
@@ -503,54 +488,6 @@ void LocationBarView::Init() {
   params.types_enabled.push_back(PageActionIconType::kVirtualCardEnroll);
   params.types_enabled.push_back(PageActionIconType::kMandatoryReauth);
 
-  if (browser_ && lens::features::IsOmniboxEntryPointEnabled()) {
-    // The persistent compact entrypoint should be positioned directly before
-    // the star icon and the prominent expanding entrypoint should be
-    // positioned in the leading position. This entrypoint will be suppressed
-    // if the AIM page action is enabled and the user meets AIM eligibility
-    // criteria, since we want to avoid both showing up when the user focuses
-    // the Omnibox.
-    if (lens::features::IsOmniboxEntrypointAlwaysVisible()) {
-      params.types_enabled.push_back(PageActionIconType::kLensOverlay);
-    } else {
-      params.types_enabled.insert(params.types_enabled.begin(),
-                                  PageActionIconType::kLensOverlay);
-    }
-  }
-
-  if (browser_ && lens::features::IsLensOverlayEduActionChipEnabled()) {
-    // Position in the leading position, like the expanding entrypoint for
-    // kLensOverlay above. While both chips may be enabled, they will not appear
-    // at the same time due to different focus behavior.
-    params.types_enabled.insert(params.types_enabled.begin(),
-                                PageActionIconType::kLensOverlayHomework);
-  }
-
-  // Because the AIM eligibility service might not be ready on startup,
-  // the AI Mode page action type is always added. Unless the main AIM
-  // omnibox entrypoint Feature is explicitly disabled, which can be used
-  // as a kill switch in case of any unanticipated issues with this
-  // approach.
-  auto* feature_list = base::FeatureList::GetInstance();
-  bool aim_omnibox_entrypoint_explicitly_disabled =
-      feature_list &&
-      feature_list->IsFeatureOverridden(
-          omnibox::kAiModeOmniboxEntryPoint.name) &&
-      !base::FeatureList::IsEnabled(omnibox::kAiModeOmniboxEntryPoint);
-  if (!aim_omnibox_entrypoint_explicitly_disabled) {
-    // Position in the leading position, like the entrypoint for
-    // kLensOverlayHomework above. While both chips may be enabled, they will
-    // not appear at the same time due to different focus behavior. The
-    // visibility of this entrypoint is dependent on whether or not the user
-    // meets AIM eligibility criteria.
-    params.types_enabled.insert(params.types_enabled.begin(),
-                                PageActionIconType::kAiMode);
-  }
-
-  if (browser_ && tab_groups::SavedTabGroupUtils::SupportsSharedTabGroups()) {
-    params.types_enabled.push_back(PageActionIconType::kCollaborationMessaging);
-  }
-
   if (browser_ && !is_popup_mode_) {
     params.types_enabled.push_back(PageActionIconType::kBookmarkStar);
   }
@@ -566,17 +503,6 @@ void LocationBarView::Init() {
       AddChildView(std::make_unique<PageActionIconContainerView>(params));
   page_action_icon_controller_ = page_action_icon_container_->controller();
 
-  if (!page_action_icon_container_->children().empty() &&
-      !aim_omnibox_entrypoint_explicitly_disabled &&
-      !IsPageActionMigrated(PageActionIconType::kAiMode)) {
-    auto* first_page_action_icon_view = static_cast<PageActionIconView*>(
-        page_action_icon_container_->children().front());
-    DCHECK(first_page_action_icon_view->action_id() == kActionAiMode)
-        << "kActionAiMode must be the first child in "
-           "PageActionIconContainerView to ensure it's the left-most page "
-           "action.";
-  }
-
   auto clear_all_button = views::CreateVectorImageButton(base::BindRepeating(
       static_cast<void (OmniboxView::*)(const std::u16string&)>(
           &OmniboxView::SetUserText),
@@ -586,6 +512,22 @@ void LocationBarView::Init() {
   clear_all_button_ = AddChildView(std::move(clear_all_button));
   RefreshClearAllButtonIcon();
 
+  // Add copy URL button
+  auto copy_url_button = views::CreateVectorImageButton(base::BindRepeating(
+      [](Browser* browser) {
+        if (browser) {
+          chrome::ExecuteCommand(browser, IDC_COPY_URL);
+        }
+      },
+      base::Unretained(browser_)));
+  copy_url_button->SetTooltipText(
+      l10n_util::GetStringUTF16(IDS_COPY_URL));
+  copy_url_button->SetImageModel(
+      views::Button::STATE_NORMAL,
+      ui::ImageModel::FromVectorIcon(kLinkChromeRefreshIcon, kColorOmniboxResultsIcon,
+                                     GetLayoutConstant(LOCATION_BAR_ICON_SIZE)));
+  copy_url_button_ = AddChildView(std::move(copy_url_button));
+
   // Initialize the location entry. We do this to avoid a black flash which is
   // visible when the location entry has just been initialized.
   Update(nullptr);
@@ -963,25 +905,9 @@ void LocationBarView::Layout(PassKey) {
     }
   };
 
-  // When the AIM page action is shown as the right-most page action in the
-  // location bar, it should be positioned flush against the right edge of the
-  // location bar.
-  // If all page actions are migrated (i.e. up to bookmark star), then the extra
-  // padding that is usually added to bridge the new and legacy containers can
-  // be discounted.
-  const bool all_page_actions_migrated =
-      IsPageActionMigrated(PageActionIconType::kBookmarkStar);
-  const int kTrailingEdgePaddingForAim =
-      IsPageActionMigrated(PageActionIconType::kAiMode) &&
-              !all_page_actions_migrated
-          ? -3
-          : 5;
   add_trailing_decoration(page_action_icon_container_,
                           /*intra_item_padding=*/0,
-                          /*edge_padding=*/
-                          IsAimLastVisiblePageAction()
-                              ? kTrailingEdgePaddingForAim
-                              : trailing_decorations_edge_padding);
+                          /*edge_padding=*/trailing_decorations_edge_padding);
   add_trailing_decoration(page_action_container_,
                           /*intra_item_padding=*/0,
                           /*edge_padding=*/trailing_decorations_edge_padding);
@@ -1000,6 +926,9 @@ void LocationBarView::Layout(PassKey) {
   add_trailing_decoration(clear_all_button_, /*intra_item_padding=*/0,
                           /*edge_padding=*/trailing_decorations_edge_padding);
 
+  add_trailing_decoration(copy_url_button_, /*intra_item_padding=*/0,
+                          /*edge_padding=*/trailing_decorations_edge_padding);
+
   // Perform layout.
   int entry_width = width();
 
@@ -1272,6 +1201,11 @@ bool LocationBarView::ShouldHidePageActionIcons() const {
 
 bool LocationBarView::ShouldHidePageActionIcon(
     PageActionIconView* icon_view) const {
+  // Bookmark star should always be visible
+  if (page_action_icon_controller_->GetIconType(icon_view) == PageActionIconType::kBookmarkStar) {
+    return false;
+  }
+
   if (ShouldHidePageActionIcons()) {
     return true;
   }
@@ -1294,25 +1228,8 @@ bool LocationBarView::ShouldHidePageActionIcon(
 
 bool LocationBarView::ShouldHidePageActionIconsForContext(
     metrics::OmniboxEventProto::PageClassification page_context) const {
-  switch (page_context) {
-    case metrics::OmniboxEventProto::
-        INSTANT_NTP_WITH_OMNIBOX_AS_STARTING_FOCUS: {
-      // When the user is on the NTP and the AIM page action is eligible to be
-      // shown, suppress all other page actions in order to minimize UI
-      // instability when going from the steady-state to the on-focus Omnibox.
-      const auto* aim_eligibility_service =
-          AimEligibilityServiceFactory::GetForProfile(profile_);
-      const bool is_aim_page_action_enabled =
-          OmniboxFieldTrial::IsAimOmniboxEntrypointEnabled(
-              aim_eligibility_service);
-      const bool hide_other_page_actions_on_ntp =
-          omnibox_feature_configs::AiModeOmniboxEntryPoint::Get()
-              .hide_other_page_actions_on_ntp;
-      return is_aim_page_action_enabled && hide_other_page_actions_on_ntp;
-    }
-    default:
-      return false;
-  }
+  // AI Mode removed - no special hiding logic needed
+  return false;
 }
 
 /*
@@ -1361,42 +1278,7 @@ bool LocationBarView::ShouldHidePageActionIconsForContext(
  * of how many migrated page actions are visible).
  */
 bool LocationBarView::IsAimLastVisiblePageAction() const {
-  int visible_migrated_page_action_count = 0;
-  bool migrated_aim_page_action_is_visible = false;
-
-  // Check PageActionContainerView (migrated page actions).
-  for (views::View* view : page_action_container_->children()) {
-    if (view->GetVisible()) {
-      visible_migrated_page_action_count++;
-      page_actions::PageActionView* page_action_view =
-          static_cast<page_actions::PageActionView*>(view);
-      if (page_action_view->GetActionId() == kActionAiMode) {
-        migrated_aim_page_action_is_visible = true;
-      }
-    }
-  }
-
-  int visible_page_action_count = 0;
-  bool aim_page_action_is_visible = false;
-
-  // Check PageActionIconContainerView (legacy page actions).
-  for (views::View* view : page_action_icon_container_->children()) {
-    if (view->GetVisible()) {
-      visible_page_action_count++;
-      PageActionIconView* icon_view = static_cast<PageActionIconView*>(view);
-      if (icon_view->action_id() == kActionAiMode) {
-        aim_page_action_is_visible = true;
-      }
-    }
-  }
-
-  if (migrated_aim_page_action_is_visible &&
-      (visible_migrated_page_action_count + visible_page_action_count) == 1) {
-    return true;
-  } else if (aim_page_action_is_visible && visible_page_action_count == 1) {
-    return true;
-  }
-
+  // AI Mode removed - always return false
   return false;
 }
 
@@ -1466,9 +1348,9 @@ void LocationBarView::RefreshBackground() {
                              ui::NativeTheme::PreferredContrast::kMore;
 
   const auto* const color_provider = GetColorProvider();
-  SkColor normal = color_provider->GetColor(kColorLocationBarBackground);
+  SkColor normal = color_provider->GetColor(kColorToolbar);
   SkColor hovered =
-      color_provider->GetColor(kColorLocationBarBackgroundHovered);
+      color_provider->GetColor(kColorToolbar);
 
   background_color_ = gfx::Tween::ColorValueBetween(opacity, normal, hovered);
   if (is_caret_visible) {
@@ -1565,20 +1447,7 @@ void LocationBarView::RefreshPageActionIconViews() {
 }
 
 void LocationBarView::RefreshAiModePageActionIconView() {
-  if (IsPageActionMigrated(PageActionIconType::kAiMode)) {
-    auto* aim_page_action_controller =
-        omnibox::AiModePageActionController::From(browser_);
-    if (aim_page_action_controller) {
-      aim_page_action_controller->UpdatePageAction();
-    }
-    return;
-  }
-
-  PageActionIconView* aim_icon_view =
-      page_action_icon_controller_->GetIconView(PageActionIconType::kAiMode);
-  if (aim_icon_view) {
-    aim_icon_view->Update();
-  }
+  // AI Mode removed - no-op
 }
 
 void LocationBarView::RefreshPageActionContainerViewAndIconsVisibility(
@@ -1912,13 +1781,12 @@ void LocationBarView::OnChanged() {
       !omnibox_view_->GetText().empty() &&
       IsVirtualKeyboardVisible(GetWidget()));
 
+  // Copy URL button is always visible
+  copy_url_button_->SetVisible(true);
+
   InvalidateLayout();
   SchedulePaint();
   UpdateChipVisibility();
-  // The AI mode page action icon view visibility depends on whether or not
-  // user text has been entered into the omnibox, so refresh the icon on
-  // changes.
-  RefreshAiModePageActionIconView();
 }
 
 const LocationBarModel* LocationBarView::GetLocationBarModel() const {
@@ -1934,10 +1802,6 @@ void LocationBarView::OnOmniboxFocused() {
   // the omnibox is intentional, snapping is better than transitioning here.
   hover_animation_.Reset();
   RefreshBackground();
-
-  // The AI mode page action icon view should only be visible when the omnibox
-  // is focused, so if there is a change in focus, refresh the icon.
-  RefreshAiModePageActionIconView();
 }
 
 void LocationBarView::OnOmniboxBlurred() {
@@ -1946,10 +1810,6 @@ void LocationBarView::OnOmniboxBlurred() {
   }
   RefreshBackground();
 
-  // The AI mode page action icon view should only be visible when the omnibox
-  // is focused, so if there is a change in focus, refresh the icon.
-  RefreshAiModePageActionIconView();
-
   location_icon_view_->Update(false, false);
 }
 
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.h b/chrome/browser/ui/views/location_bar/location_bar_view.h
index 507ca6272a7b1..7993f100b5281 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.h
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.h
@@ -570,6 +570,9 @@ class LocationBarView
   // user to clear all text.
   raw_ptr<views::ImageButton> clear_all_button_ = nullptr;
 
+  // A button to copy the current URL to clipboard.
+  raw_ptr<views::ImageButton> copy_url_button_ = nullptr;
+
   // Animation to change whole location bar background color on hover.
   gfx::SlideAnimation hover_animation_{this};
 
diff --git a/chrome/browser/ui/views/tabs/tab.cc b/chrome/browser/ui/views/tabs/tab.cc
index 93a656042af50..d5306a85b1e0c 100644
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -1167,10 +1167,10 @@ void Tab::UpdateIconVisibility() {
 #if BUILDFLAG(IS_CHROMEOS)
     // Hide tab close button for OnTask if locked. Only applicable for non-web
     // browser scenarios.
-    showing_close_button_ = !controller_->IsLockedForOnTask();
+    showing_close_button_ = !controller_->IsLockedForOnTask() && mouse_hovered_;
 #else
-    // Close button is shown on active tabs regardless of the size.
-    showing_close_button_ = true;
+    // Close button is shown on active tabs only when hovered.
+    showing_close_button_ = mouse_hovered_;
 #endif  // BUILDFLAG(IS_CHROMEOS)
     available_width -= close_button_width;
 
@@ -1196,11 +1196,12 @@ void Tab::UpdateIconVisibility() {
       available_width -= favicon_width;
     }
 
+    // Only show close button on hover for inactive tabs
     showing_close_button_ =
 #if BUILDFLAG(IS_CHROMEOS)
         !controller_->IsLockedForOnTask() &&
 #endif
-        large_enough_for_close_button;
+        large_enough_for_close_button && mouse_hovered_;
     if (showing_close_button_) {
       available_width -= close_button_width;
     }
diff --git a/chrome/browser/ui/views/tabs/tab_style_views.cc b/chrome/browser/ui/views/tabs/tab_style_views.cc
index fe66c423ab248..1346e9de8e2e5 100644
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -210,8 +210,6 @@ SkPath TabStyleViewsImpl::GetPath(TabStyle::PathType path_type,
   CHECK(tab());
   const int stroke_thickness = GetStrokeThickness(flags.force_active);
 
-  const TabStyle::TabSelectionState state = GetSelectionState();
-
   // We'll do the entire path calculation in aligned pixels.
   // TODO(dfried): determine if we actually want to use `stroke_thickness` as
   // the inset in this case.
@@ -229,8 +227,8 @@ SkPath TabStyleViewsImpl::GetPath(TabStyle::PathType path_type,
                                   scale;
 
   // Selected, hover, and inactive tab fills are a detached squarcle tab.
-  if ((path_type == TabStyle::PathType::kFill &&
-       state != TabStyle::TabSelectionState::kActive) ||
+  // Active tabs also use this shape for consistent rounded rectangle appearance.
+  if ((path_type == TabStyle::PathType::kFill) ||
       path_type == TabStyle::PathType::kHighlight ||
       path_type == TabStyle::PathType::kInteriorClip ||
       path_type == TabStyle::PathType::kHitTest) {
@@ -1031,8 +1029,8 @@ void TabStyleViewsImpl::PaintBackgroundStroke(
   }
 
   SkPath outer_path =
-      GetPath(TabStyle::PathType::kBorder, canvas->image_scale(),
-              {.force_active = is_active, .should_paint_extension = false});
+      GetPath(TabStyle::PathType::kFill, canvas->image_scale(),
+              {.force_active = is_active});
   gfx::ScopedCanvas scoped_canvas(canvas);
   float scale = canvas->UndoDeviceScaleFactor();
   cc::PaintFlags flags;
@@ -1063,12 +1061,19 @@ void TabStyleViewsImpl::PaintSeparators(gfx::Canvas* canvas) const {
 
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
+  flags.setStyle(cc::PaintFlags::kStroke_Style);
+  flags.setStrokeWidth(1.0f * scale);
+
+  // Draw simple vertical lines instead of rounded rectangles
   flags.setColor(separator_color(separator_opacities.left));
-  canvas->DrawRoundRect(separator_bounds.leading,
-                        tab_style()->GetSeparatorCornerRadius() * scale, flags);
+  float left_x = separator_bounds.leading.x() + separator_bounds.leading.width() / 2;
+  canvas->DrawLine(gfx::PointF(left_x, separator_bounds.leading.y()),
+                   gfx::PointF(left_x, separator_bounds.leading.bottom()), flags);
+
   flags.setColor(separator_color(separator_opacities.right));
-  canvas->DrawRoundRect(separator_bounds.trailing,
-                        tab_style()->GetSeparatorCornerRadius() * scale, flags);
+  float right_x = separator_bounds.trailing.x() + separator_bounds.trailing.width() / 2;
+  canvas->DrawLine(gfx::PointF(right_x, separator_bounds.trailing.y()),
+                   gfx::PointF(right_x, separator_bounds.trailing.bottom()), flags);
 }
 
 bool TabStyleViewsImpl::IsLeftSplitTab(const Tab* tab) const {
diff --git a/chrome/browser/ui/views/toolbar/app_menu.cc b/chrome/browser/ui/views/toolbar/app_menu.cc
index d10401dad12b2..da0cca83c497f 100644
--- a/chrome/browser/ui/views/toolbar/app_menu.cc
+++ b/chrome/browser/ui/views/toolbar/app_menu.cc
@@ -1597,6 +1597,7 @@ void AppMenu::PopulateMenu(MenuItemView* parent, MenuModel* model) {
               views::LayoutProvider::Get()->GetDistanceMetric(
                   views::DISTANCE_CONTROL_VERTICAL_TEXT_PADDING),
               ui::kColorAppMenuUpgradeRowBackground);
+          item->SetForegroundColorId(ui::kColorAppMenuUpgradeRowSubstringForeground);
         }
         break;
       }
diff --git a/chrome/browser/ui/views/toolbar/toolbar_view.cc b/chrome/browser/ui/views/toolbar/toolbar_view.cc
index 0a324e3999d7a..e86eec19bd872 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_view.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.cc
@@ -413,6 +413,16 @@ void ToolbarView::Init() {
 
   location_bar_ = container_view_->AddChildView(std::move(location_bar));
 
+  // Add a divider after the location bar
+  auto location_bar_divider = std::make_unique<views::View>();
+  location_bar_divider_ = container_view_->AddChildView(std::move(location_bar_divider));
+  location_bar_divider_->SetPreferredSize(
+      gfx::Size(GetLayoutConstant(TOOLBAR_DIVIDER_WIDTH),
+                GetLayoutConstant(TOOLBAR_DIVIDER_HEIGHT)));
+  location_bar_divider_->SetBackground(views::CreateRoundedRectBackground(
+    kColorToolbarSeparator,
+      GetLayoutConstant(TOOLBAR_DIVIDER_CORNER_RADIUS)));
+
   if (extensions_container) {
     extensions_container_ =
         container_view_->AddChildView(std::move(extensions_container));
@@ -1008,6 +1018,12 @@ void ToolbarView::InitLayout() {
         gfx::Insets::VH(0, GetLayoutConstant(TOOLBAR_DIVIDER_SPACING)));
   }
 
+  if (location_bar_divider_) {
+    location_bar_divider_->SetProperty(
+        views::kMarginsKey,
+        gfx::Insets::VH(0, GetLayoutConstant(TOOLBAR_DIVIDER_SPACING)));
+  }
+
   constexpr int kToolbarFlexOrderStart = 1;
 
   // TODO(crbug.com/40929989): Ignore containers till issue addressed.
diff --git a/chrome/browser/ui/views/toolbar/toolbar_view.h b/chrome/browser/ui/views/toolbar/toolbar_view.h
index 415970aadb0ed..d29a28f80fb0c 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_view.h
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.h
@@ -295,6 +295,7 @@ class ToolbarView : public views::AccessiblePaneView,
   raw_ptr<SplitTabsToolbarButton> split_tabs_ = nullptr;
   raw_ptr<CustomTabBarView> custom_tab_bar_ = nullptr;
   raw_ptr<LocationBarView> location_bar_ = nullptr;
+  raw_ptr<views::View> location_bar_divider_ = nullptr;
   raw_ptr<ExtensionsToolbarContainer> extensions_container_ = nullptr;
   raw_ptr<views::View> toolbar_divider_ = nullptr;
   raw_ptr<BatterySaverButton> battery_saver_button_ = nullptr;
diff --git a/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler.cc b/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler.cc
index 202099eee781e..832ca90c1538c 100644
--- a/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler.cc
+++ b/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler.cc
@@ -583,7 +583,7 @@ void NewTabPageHandler::RegisterProfilePrefs(PrefRegistrySimple* registry) {
   registry->RegisterIntegerPref(
       prefs::kNtpCustomizeChromeSidePanelAutoOpeningsCount, 0);
   registry->RegisterBooleanPref(prefs::kNtpCustomizeChromeExplicitlyClosed,
-                                false);
+                                true);
   registry->RegisterBooleanPref(prefs::kNtpCustomizeChromeIPHAutoOpened, false);
 }
 
diff --git a/components/search/ntp_features.cc b/components/search/ntp_features.cc
index 406d9402d41e1..6d2ea1d68430b 100644
--- a/components/search/ntp_features.cc
+++ b/components/search/ntp_features.cc
@@ -98,7 +98,7 @@ BASE_FEATURE(kNtpDummyModules, base::FEATURE_DISABLED_BY_DEFAULT);
 
 // If enabled, Google Drive module will be shown.
 // This is a kill switch. Keep indefinitely.
-BASE_FEATURE(kNtpDriveModule, base::FEATURE_ENABLED_BY_DEFAULT);
+BASE_FEATURE(kNtpDriveModule, base::FEATURE_DISABLED_BY_DEFAULT);
 
 // If enabled, the NTP Drive module does not require sync.
 BASE_FEATURE(kNtpDriveModuleHistorySyncRequirement,
@@ -121,7 +121,7 @@ BASE_FEATURE(kNtpMiddleSlotPromo, base::FEATURE_ENABLED_BY_DEFAULT);
 
 // If enabled, middle slot promo will be dismissed from New Tab Page until new
 // promo message is populated
-BASE_FEATURE(kNtpMiddleSlotPromoDismissal, base::FEATURE_ENABLED_BY_DEFAULT);
+BASE_FEATURE(kNtpMiddleSlotPromoDismissal, base::FEATURE_DISABLED_BY_DEFAULT);
 
 // Dummy feature to set param "NtpModulesLoadTimeoutMillisecondsParam".
 // This is used for an emergency Finch param. Keep indefinitely.
diff --git a/ui/views/controls/menu/menu_item_view.h b/ui/views/controls/menu/menu_item_view.h
index cd70752a23e34..6725f520d89c2 100644
--- a/ui/views/controls/menu/menu_item_view.h
+++ b/ui/views/controls/menu/menu_item_view.h
@@ -186,6 +186,10 @@ class VIEWS_EXPORT MenuItemView : public View, public LayoutDelegate {
 
   std::optional<ui::ColorId> GetSelectedColorId() { return selected_color_id_; }
 
+  void SetForegroundColorId(std::optional<ui::ColorId> foreground_color_id) {
+    foreground_color_id_ = foreground_color_id;
+  }
+
   void SetHighlightWhenSelectedWithChildViews(
       bool highlight_when_selected_with_child_views) {
     highlight_when_selected_with_child_views_ =
@@ -596,10 +600,6 @@ class VIEWS_EXPORT MenuItemView : public View, public LayoutDelegate {
   // Calculates the X coordinate of the icon.
   int CalculateIconX(const ImageView* icon_view) const;
 
-  void SetForegroundColorId(std::optional<ui::ColorId> foreground_color_id) {
-    foreground_color_id_ = foreground_color_id;
-  }
-
   // Returns the corresponding margin from the `MenuConfig` if
   // `vertical_margin_` is not set.
   int GetVerticalMargin() const;
diff --git a/ui/webui/resources/cr_components/searchbox/searchbox.css b/ui/webui/resources/cr_components/searchbox/searchbox.css
index 34e70f33711a1..dc4fdb93e0fa3 100644
--- a/ui/webui/resources/cr_components/searchbox/searchbox.css
+++ b/ui/webui/resources/cr_components/searchbox/searchbox.css
@@ -299,7 +299,7 @@ cr-searchbox-icon {
 
 :host([use-webkit-search-icons_][compose-button-enabled]) #voiceSearchButton,
 :host([use-webkit-search-icons_][compose-button-enabled]) #lensSearchButton {
-  background-color: #1F1F1F;
+  background-color: var(--color-searchbox-lens-voice-icon-background);
 }
 
 :host([compose-button-enabled][searchbox-lens-search-enabled_]) {
